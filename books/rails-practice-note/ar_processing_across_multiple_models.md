---
title: "[ActiveRecord] 複数のモデルにまたがる処理を書きたいときの設計方法"
---

# [ActiveRecord] 複数のモデルにまたがる処理を書きたいときの設計方法

Railsアプリを書いているときに迷うケースとして、複数のモデルにまたがる処理を書きたくなるときがあります。そのとき、どのような設計ができるのかを考えてみます。

## まとめ

- 複数のモデルにまたがる処理を書きたいときに試したい設計
  - 主となるモデルへ実装する
  - イベント型モデルを探す
  - POROをつくる
- Rails wayから外れる部分は、チームでルールをつくっていく
  - ルールに従って実装するクラス、ファイルを一意に決められれば、迷う時間や議論する時間を減らせる
  - これからつくる機能の実装場所をチームメンバー全員に問うたときに、全員が同じ実装場所を指すのが理想
- モデルを分割する良いタイミングは、バリデーションやコールバックに分岐を書きたくなったとき
  - Fatモデルを怖がりすぎない
- モデルを分割する1つの方法はフォームオブジェクトを切り出すこと
  - Railsのモデルのバリデーションは、DBとフォームの両方で共用される
  - フォーム側のバリデーションをフォームオブジェクトとして切り出し、モデルのバリデーションはDB専業にする
- Service層を入れるのはできるだけやめてほしい

## 主となるモデルへ実装する

複数のモデルにまたがる処理を書きたいときの手軽な手段は「主となるモデルを決めて実装する」です。

例として、ECサービスのカートを題材に考えてみます。CartモデルとCartItemモデルの2つで構成され、Cartモデルはユーザーごとのカートを管理する責務を持ち、CartItemはカート内の個々の商品を管理する責務を持つモデルであるとします。特定の商品を値引きするクーポンがあったとき、これを適用する仕事をCartモデルの責務とするか、またはCartItemモデルの責務とするか、のどちらかで実装する方法です。値引きは特定商品が対象のため、CartItemモデルの責務とするのか、カート全体で複数クーポンの適用条件を考えたり合計金額を考えるためにCartモデルの責務とするのか、迷うところです。

このとき、Cartモデルを主、CartItemを従と考えて、Cartモデルの責務としてCartモデルにクーポン適用のメソッドを実装するのが「主となるモデルへ実装する」方法です。Cartモデルにメソッドを実装するときにCartItemモデルの情報が必要になれば、メソッドへ引数として渡したり、インスタンス変数などでオブジェクト群を保持する設計になります。

実際に実装すると、主モデルにメインとなるメソッドが実装されるとともに、従モデルに関する処理は従モデルのメソッドへ委譲する設計になることも多いと思います。結果、責務が分担され、良い設計ができるかもしれません。

この方法の良いところはモデルを増やさずに済むため、手軽なところです。まずはこれでやってみて、実装されていくメソッドが増えてきてから分割や後述の方法を検討するのは良い方法だと思います。後述の方法、イベント型モデルを探すやPOROをつくるを最初からうまくやるのは難しいため、この方法をつかって良い分割のための情報が貯めることで、分割時に失敗する確率を減らすことができます。

この方法を行った結果として、主モデルに実装が集まってくる傾向になります。特に、従になるモデルが複数あるような設計のときに、主モデルにメソッド群を実装していくと、後から実装するエンジニアは「このプロジェクトでは主モデルに実装を集めるのかもしれない」と考えはじめるため、責務が従のモデルにある処理も主モデルのメソッドとして集めるようになるかもしれません。こうなる可能性も頭の片隅に置いて設計したり判断するのがお勧めです。

この方法の弱点として、主従を考えづらい2つのモデル間ではどちらのモデルへ実装すれば良いか迷うため、適用が難しいことがあります。


## イベント型モデルを探す

「イベント型モデル」を探してみる設計方法。ここでは「行為を記録するモデル」をイベント型モデルと呼びます。たとえば、「Order(注文)」、「Shipment(出荷)」、「Payment(支払い)」らはイベント型モデルの例です。名詞であるモデル名に「～する」をつけると行為になるようなケースが該当します。

複数のモデルにまたがる処理を書きたい例として、商品を入荷するケースを考えます。このとき、「在庫(Stockモデル)を増やす」「支払った代金を銀行口座(BankAccountモデル)から減らす」を行いたいとすると、StockモデルとBankAccountモデルとにまたがる処理になるため、どちらのモデルに書くかで迷うかもしれません。

このようなケースでは、行為に着目するときれいに設計できます。今回は「入荷する」行為をしているので、イベント型モデルである「Arrival(入荷)モデル」をつくります。Arrivalモデルは、さきほどの「在庫を増やす」「支払った代金を銀行口座から減らす」の2つの処理を行う責務を持つのに適したモデルになっているので、Arrivalモデルにメソッド（たとえばreceivedメソッド）をつくってその中でStockモデルとBankAccountモデルを操作します。

このように適切なイベント型モデルを探すことで、複数のモデルにまたがる処理を書きたい問題が解消して、責務が正しく設計された1つのモデルに処理を書くことができるようになります。

このときのイベント型モデルは、必ずしもActiveRecordを継承してDBに記録しなくても構いません。たとえばActiveModelとして設計したり、後ろで説明するPOROとしてただのRubyクラスで設計しても良いでしょう。そして将来、記録したくなったときにActiveRecordを継承する形に書き換えるのも良い方法です。このようにActiveRecordを継承しないモデルクラスも、app/modelsフォルダ以下に配置して良いと考えています。

イベント型テーブルをつかったRDB設計の方法は書籍「楽々ERDレッスン」の説明がわかりやすいです。

- [楽々ERDレッスン 第1回：「お持ち帰りご注文用紙」編](https://codezine.jp/article/detail/154)

イベント型エンティティ（本資料でイベント型モデルと書いているもの）とRailsでの設計については諸橋さんの講演資料 "Simplicity on Rails: RDB, REST and Ruby" にわかりやすく説明されています。

- [Simplicity on Rails: RDB, REST and Ruby](https://speakerdeck.com/moro/simplicity-on-rails-rdb-rest-and-ruby)

また、イベント型テーブルとモデルなど、Railsアプリにおける設計についてはtexta.fmポッドキャストにて詳しく説明されています。

- [texta.fm](https://open.spotify.com/show/2BdZHve9cIU6c8OFyz7LeB)

## POROをつくる

POROをつくる設計方法です。POROとはPlain Old Ruby Objectの略で、何も継承していないただのクラスのことです。複数のモデルにまたがる処理を書きたくなったら、やりたいことを責務として持つPOROをつくって、そこに処理を書きます。POROのクラスもモデルやイベント型モデルと同様にapp/models以下に置くと良いでしょう。

ここはRails wayから外れる部分なので、チームでこの部分に新しいルールをつくっていくことをお勧めします。

Rails wayはRailsのとても便利な仕組みです。Rails wayがあるおかげで、初めて一緒に仕事をするメンバーでもRailsアプリの設計について多くの知識を共有した状態で仕事を始めることができます。一般的なRails wayから外れたところでも、自分たちのRailsアプリにルールがある範囲をうまく広げていければ、ルールに従って編集するクラス、ファイルを一意に決めて実装することができます。一意に決めることができれば、迷う時間や議論する時間が発生することなく、また、同じ機能が複数の場所に散らばって実装されることもなくなります。

理想は機能の実装場所をチームメンバー全員に問うたときに、全員が同じ実装場所を指す状態をつくることです。このときのメンバー全員とは、未来にこのチームに加わるメンバーも含んだ全ての人のことです。

POROでのルールをつくる例として、「クラス名には返すオブジェクトの名前を名詞でつける」は、つくりやすいお勧めのルールです。一般的なActiveRecordを継承したモデルがこのような名付けをされることにならったものです。

たとえばBookモデルには本に関する処理が書かれ、戻り値としてBookオブジェクトまたはBookオブジェクトが入った配列を返すメソッドを多く持ちます。BookオブジェクトにはBookの属性を返すメソッドや、Bookオブジェクトを便利に扱うメソッド群が用意されているでしょう。「クラス名には返すオブジェクトの名前を名詞でつける」なルールをつくってをPOROにも応用すれば、クラス名のブレは減り、モデルと同様に考えることができる場面を増やすことができます。

ECサービスのカート(Cart)をPOROで実装する例を考えると、POROとしてCartクラスをつくり、CartクラスにはCartオブジェクトを返すメソッドが用意されていて、Cartオブジェクトにはカートを便利に扱う様々なメソッドを呼び出せるようにしておくことになります。

データを記録して永続化させたくなったときは、ActiveRecordを継承させてPOROからモデルに変更しても良いでしょう。そのときに「クラス名には返すオブジェクトの名前を名詞でつける」ルールにしたがっていれば、クラス名を変更せずにモデルに変えることができます。

チーム内でのルールを広めていくことで、実装のブレを減らして、意識を合わせることにつながります。ほかにもたとえば、名前空間をつけるときの指針や、特別な意味を持つ用語選定などはチーム内のルールにしておくと良さそうです。

## モデルを分割する良いタイミング

「Fatモデル」という言葉があります。モデルのコードが肥大化してメンテナンスが難しくなってしまった状態を指します。

一方で、分割に失敗した結果、メンテナンスが難しくなることもあります。下手に分割するよりも、太っていた方がマシなこともあります。分割は難しい作業なので、失敗することも多くあるからです。分割時期を遅らせると分割後の設計を判断する情報が増えるので、分割時期を遅らせるほどうまく分割できる確率が上がります。Fatモデルを怖がりすぎて早くから分割してしまうと、逆効果なことも多いです

とはいえ、そのまま太りつづけるのも困るわけです。では、分割のタイミングとして良いのはいつなのでしょうか。

後藤優一さんの講演 [「Ruby on Railsの正体と向き合い方」](https://speakerdeck.com/yasaichi/what-is-ruby-on-rails-and-how-to-deal-with-it) では、「限界の表出の仕方の1つは、特定の条件でValidations/Callbacksを実行する or スキップすること」と話されています。具体例としては、モデルのバリデーションやコールバックを分岐するために `if: :condition?`、`on: :context` らが書かれたときや、保存時に `save(validate: false)` のようにバリデーションを実行しないコードが書かれたときです。これらが書かれたときはモデル分割の良いタイミングであることが多いので、分割を検討することをお勧めします。

ちなみに、モデルが太っているかどうかを行数で判断するのは、私はあまり良い方法ではないと考えています。なぜなら、各メソッド同士が独立していて結合が疎であれば、行数が多くても困ることは少ないからです。

## フォームオブジェクトをつかってモデルを分割する

モデルを分割する1つの方法として、フォームオブジェクトを切り出すことを考えてみます。

Railsでのモデルのバリデーションは、DBとフォーム（より一般的にはフロントエンド側での入出力）の両方で共通してつかわれます。モデルにバリデーションを書くと、DBに対するバリデーションと、フォームでのバリデーションとで共用されて、多くのケースでそれで都合が良いわけです。

ここで、あるDBテーブルへ保存するためのフォームが複数になったときを考えてみましょう。バリデーションはモデルで1種類なので、複数のフォームで異なるバリデーションをつかいたいケースでは、なんらかの方法でバリデーションを分岐させなくてはなりません。

validationメソッドに分岐を書くことはメンテナンスを難しくします。このタイミングがモデルの分割を考える良い機会なので、フォームオブジェクトをつかってモデルを分割してみましょう。各フォームごとにフォームオブジェクトをつくり、各フォームごとのバリデーションをフォームオブジェクトに実装します。モデルにあるバリデーションは、DBのバリデーション専業にします。

フォームオブジェクトをつくるときは、ActiveModel::Modelモジュール(Rails7.0からはActiveModel::APIモジュールも新設されました)をincludeすることで、属性のハッシュで 初期化する機能や、バリデーションを設定して実行できる機能、form_withとやりとりする機能などをかんたんに追加することができます。

詳細はRails APIのページにサンプルコードがあります。

- https://api.rubyonrails.org/classes/ActiveModel/Model.html
- https://api.rubyonrails.org/classes/ActiveModel/API.html

また、パーフェクトRails増補改訂版 12-3 フォームオブジェクトの節にも解説があります。

## Service層を入れるのはできるだけやめてほしい

Service層を入れることは、私はアンチパターンであると考えていて、避けることをお勧めしています。ここから私の考えを述べます。

Railsは層(レイヤー)分割を減らして、書くコード量を減らす設計になっています。ここでの層はたとえばモデル、コントローラ、ビューなどです。モデルを例に挙げると、ORマッパー、バリデーション、コールバック、フォームオブジェクト、ビジネスロジック置き場といろんな機能をあわせ持っています。

一般に、結合を増やすことは、独立であることと比べて変更に対する影響範囲が増えるといった弱点を持つことになります。一方で、うまく結合させられれば重複したコードを1カ所に書けるようになり、コード量を減らすことができ、高い生産性へつながります。また、クラスやファイルを減らすことができ、登場人物を減らすことで全体の把握を容易にする利点もあります。

Railsのモデルは、一緒のクラスに集めて都合が良いものをたくさん集めることで、コード量を減らしています。層を増やすことは、Railsの長所を消す方向に働きかねず、新しい層を入れるのは相当の覚悟を持って挑まねばならない作業です。

また、Service層はみんなが頭の中で考えているServiceについての認識がバラバラになるという問題が起こりがちです。別の文脈でService層についての知識を持っている人や、それを持たない人で、同じものについて話しているつもりがすれ違いが起こることがあります。それらをすり合わせるときに、「私の考える最強のService対決」になってしまうと議論に時間がかかり、着地点をみつけていくのも難しくなります。

Service層を入れるよりも、前述したようにモデルの概念を拡張していったり、POROのようなシンプルな考え方からはじめて、チームでルールを育てていく方がうまくいくのではないかと私は考えています。

Service層を入れたときの具体的な問題としては、Serviceオブジェクト間でのメソッド共有が難しいことと、モデルと違った設計方針となるためオブジェクトの責務の特徴をつくりづらく、ビジネスロジックをどこへ書くか迷いやすくなること、などが困りやすい点だと考えています。

## コラム: 会社のメタファーをつかった設計

Railsアプリを書いていくときに、会社のメタファーをつかった設計ルールをつくるとアプリ全体を把握しやすくなるのではないかという仮説を持っています。ここまでで書いてきたことと組み合わせることが難しい面もあるので、「うまくいくかもしれない仮説の1つ」という立ち位置でコラムとして書きます。

この設計では、Payer(支払いをする人)、Accountant（会計士）、Postman(メール配達人)といった「〇〇する人」であるクラスをつくり、それぞれの責務にあわせて機能を実装し、各オブジェクトに仕事をしてもらいます。

会社では、「□□の仕事なら〇〇さんに頼むよね」という人がいて、その人に仕事を頼むことがよくあります。「人に仕事を頼む」「人に責務が割り当たっている」ということはイメージしやすいので、それをメタファーとしてアプリを設計していくとうまく設計できるのではないかと考えています。そして「会社」というメンバ間でイメージを共有しやすいメタファーをつかうことで、アプリ設計を考えることを容易にすることが狙いです。

会社で特定の仕事が多くなってきたら、最初は1人でまわしていた仕事を複数人で分担するようになります。コード上でも同様に、最初はPayerクラスが全ての支払い（とはいえ最初は1種類なことが多い）を担当していたのが、BankPayer（銀行の支払いをする人）、CardPayer（クレジットカードの支払いをする人）のように責務を分けて複数のクラスへ分割して担当させていきます。さらにクラスが増えてきたら、課や部にあたるネームスペースを導入するのもいいでしょう。

ルールとして文章にすると、例としては次のようになります。

- クラス名は「〇〇する人」な名前をつける
- 「〇〇が得意な人」と言い表せるように、それぞれのクラスとオブジェクトのキャラを立てて責務をはっきりさせる
- ネームスペースをつけるときは部課の名前をつける
- このクラス群を置くフォルダ名はapp/guildesにする

「〇〇が得意な人」とオブジェクトのキャラを立てて責務をはっきりさせることが重要です。似たクラスをつくってしまうと、登場機会が失われ、いつしかつかわれなくなってしまいます。または、同じ役割のコードが複数の場所にできてしまうことになります。

私がこの設計方法を小規模なアプリで試したときには、たいへんうまく設計ができました。一方で弱みもあり、この前の節までで書いてきた「クラス名には返すオブジェクトの名前を名詞でつける」と組み合わせることは難しいです。また、機能を実装するときに「〇〇する人クラス」とモデルとどちらに処理を書くかで迷うことがあるのも弱点です。
